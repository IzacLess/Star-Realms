<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Star Realms Tracker — Big UI (Hold Fix)</title>

<!-- Russo One -->
<link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">

<style>
:root{
  --bg:#05060a;
  --panel:#0f1720;
  --glass: rgba(255,255,255,0.03);
  --accent-green:#3CF06E;
  --accent-red:#FF3B3B;
  --accent-yellow:#FFD34D;
  --accent-blue:#4DA3FF;
  --accent-grey:#9aa0a6;
  --text:#ffffff;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);font-family:'Russo One',system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;color:var(--text);-webkit-tap-highlight-color:transparent}
canvas#starfield{position:fixed;inset:0;z-index:0}
canvas#fireworks{position:fixed;inset:0;z-index:7;pointer-events:none}

/* app */
.app{position:relative;z-index:2;display:flex;height:100vh;width:100vw;align-items:stretch}
.half{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:2vh 3vw;position:relative;overflow:hidden;border-left:1px solid rgba(255,255,255,0.03)}
.half:first-child{border-left:none}
/* flip second half so it faces other player */
.half.flip{transform:rotate(180deg)}
/* active glow around whole half (soft & subtle) */
.half.active{
  box-shadow: inset 0 0 120px rgba(77,163,255,0.06), 0 0 0 6px rgba(77,163,255,0.02);
  transition: box-shadow .35s ease;
}

/* header/authority */
.title{font-size:clamp(0.9rem,1.8vw,1.4rem);letter-spacing:1px;margin-bottom:0.6vh;color:rgba(255,255,255,0.95)}
.authority{display:flex;align-items:center;gap:1ch;margin:0.8vh 0 2vh 0}
.authority .label{color:var(--accent-green);font-size:clamp(1rem,2.2vw,1.4rem);opacity:0.95}
.authority .value{font-size:clamp(4rem,12.5vw,9rem);line-height:1;color:#fff;text-shadow:0 0 24px rgba(60,240,110,0.25);-webkit-text-stroke:0.9px rgba(0,0,0,0.3)}

/* grid 2x2 */
.grid{width:100%;max-width:760px;display:grid;grid-template-columns:1fr 1fr;gap:2.6vh 3.4vw;align-items:stretch;justify-items:stretch;padding:0 1vw}
.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:18px;padding:2.2vh 1.6vw;display:flex;flex-direction:column;align-items:center;justify-content:center;min-height:calc(12vh + 6vw);box-shadow:0 14px 28px rgba(0,0,0,0.55);border:1px solid rgba(255,255,255,0.04)}
.card .heading{font-size:clamp(1rem,2.6vw,1.6rem);margin-bottom:0.9vh;letter-spacing:1px}
.card .value{font-size:clamp(2rem,6.4vw,4rem);margin-bottom:1vh}

/* big buttons / layout */
.btn-row{display:flex;align-items:center;justify-content:space-between;width:100%;gap:1vw}
.btn{flex:0 0 46%;display:inline-flex;align-items:center;justify-content:center;height:calc(7vh + 2vw);border-radius:12px;color:var(--text);font-size:clamp(1.4rem,4.2vw,2.6rem);font-weight:700;border:none;cursor:pointer;user-select:none}
.btn:active{transform:scale(.98)}
/* bright high contrast color variants */
.btn.combat{background:var(--accent-red);color:white;box-shadow:0 10px 22px rgba(255,59,59,0.18)}
.btn.trade{background:var(--accent-yellow);color:rgba(0,0,0,0.9);box-shadow:0 10px 22px rgba(255,211,77,0.18)}
.btn.discards{background:var(--accent-blue);color:white;box-shadow:0 10px 22px rgba(77,163,255,0.16)}

.end-card{display:flex;align-items:center;justify-content:center}
.end-btn{width:100%;height:100%;border-radius:14px;background:var(--accent-red);color:white;font-size:clamp(1.6rem,4vw,3rem);border:none;cursor:pointer;padding:1rem;font-weight:800}
.end-btn.attack{box-shadow:0 18px 44px rgba(255,59,59,0.28);outline:3px solid rgba(255,59,59,0.06)}
.end-btn:active{transform:scale(.98)}

/* small fullscreen button */
.fs-btn{position:fixed;right:10px;top:10px;z-index:9;background:rgba(255,255,255,0.06);border-radius:8px;padding:8px 10px;font-size:1.1rem;border:none;color:var(--text);cursor:pointer}
.fs-btn:hover{background:rgba(255,255,255,0.12)}

/* winner overlay (behind fireworks drawn above it but fireworks z-index is higher so they show in front) */
#overlay{position:fixed;inset:0;z-index:6;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);color:white;flex-direction:column;padding:4vh}
#overlay h1{font-size:clamp(2.2rem,7.6vw,5.4rem);margin:0 0 1vh 0;text-align:center;text-shadow:0 0 24px rgba(255,255,255,0.18)}
#overlay .sub{font-size:clamp(1rem,2.2vw,1.6rem);opacity:0.95;margin-bottom:2vh}
#overlay .new{padding:1rem 1.6rem;border-radius:12px;background:#fff;color:#000;border:1px solid rgba(0,0,0,0.06);font-size:1.05rem}

/* responsive tweaks for very small phones */
@media (max-width:520px){
  .card{min-height:calc(18vh + 6vw)}
  .authority .value{font-size:clamp(3.2rem,18vw,7rem)}
}
</style>
</head>
<body>

<!-- starfield and fireworks canvases -->
<canvas id="starfield"></canvas>
<canvas id="fireworks"></canvas>

<!-- fullscreen control -->
<button id="fsBtn" class="fs-btn" aria-label="Toggle fullscreen">⛶</button>

<!-- app -->
<div class="app" id="app">
  <!-- Player 1 -->
  <section class="half" id="p1">
    <div class="title">PLAYER 1</div>
    <div class="authority"><div class="label" style="color:var(--accent-green)">AUTHORITY</div><div id="p1-authority" class="value authority-value">50</div></div>

    <div class="grid">
      <div class="card">
        <div class="heading" style="color:var(--accent-red)">COMBAT</div>
        <div id="p1-combat" class="value">0</div>
        <div class="btn-row">
          <button class="btn combat" data-player="p1" data-type="combat" data-delta="-1">−</button>
          <button class="btn combat" data-player="p1" data-type="combat" data-delta="1">+</button>
        </div>
      </div>

      <div class="card">
        <div class="heading" style="color:var(--accent-yellow)">TRADE</div>
        <div id="p1-trade" class="value">0</div>
        <div class="btn-row">
          <button class="btn trade" data-player="p1" data-type="trade" data-delta="-1">−</button>
          <button class="btn trade" data-player="p1" data-type="trade" data-delta="1">+</button>
        </div>
      </div>

      <div class="card">
        <div class="heading" style="color:var(--accent-grey)">DISCARDS</div>
        <div id="p1-discards" class="value">0</div>
        <div class="btn-row">
          <button class="btn discards" data-player="p1" data-type="discards" data-delta="-1">−</button>
          <button class="btn discards" data-player="p1" data-type="discards" data-delta="1">+</button>
        </div>
      </div>

      <div class="card end-card">
        <button id="p1-end" class="end-btn">END TURN</button>
      </div>
    </div>
  </section>

  <!-- Player 2 (flipped) -->
  <section class="half flip" id="p2">
    <div class="title">PLAYER 2</div>
    <div class="authority"><div class="label" style="color:var(--accent-green)">AUTHORITY</div><div id="p2-authority" class="value authority-value">50</div></div>

    <div class="grid">
      <div class="card">
        <div class="heading" style="color:var(--accent-red)">COMBAT</div>
        <div id="p2-combat" class="value">0</div>
        <div class="btn-row">
          <button class="btn combat" data-player="p2" data-type="combat" data-delta="-1">−</button>
          <button class="btn combat" data-player="p2" data-type="combat" data-delta="1">+</button>
        </div>
      </div>

      <div class="card">
        <div class="heading" style="color:var(--accent-yellow)">TRADE</div>
        <div id="p2-trade" class="value">0</div>
        <div class="btn-row">
          <button class="btn trade" data-player="p2" data-type="trade" data-delta="-1">−</button>
          <button class="btn trade" data-player="p2" data-type="trade" data-delta="1">+</button>
        </div>
      </div>

      <div class="card">
        <div class="heading" style="color:var(--accent-grey)">DISCARDS</div>
        <div id="p2-discards" class="value">0</div>
        <div class="btn-row">
          <button class="btn discards" data-player="p2" data-type="discards" data-delta="-1">−</button>
          <button class="btn discards" data-player="p2" data-type="discards" data-delta="1">+</button>
        </div>
      </div>

      <div class="card end-card">
        <button id="p2-end" class="end-btn">END TURN</button>
      </div>
    </div>
  </section>
</div>

<!-- overlay -->
<div id="overlay" role="dialog" aria-modal="true">
  <h1 id="overlay-text">PLAYER X WINS!</h1>
  <div class="sub">Tap New Game to reset</div>
  <button id="new-game" class="new">NEW GAME</button>
</div>

<script>
/* =========================
   App state
   ========================= */
const state = {
  current: 'p1',
  p1: {authority:50, combat:0, trade:0, discards:0},
  p2: {authority:50, combat:0, trade:0, discards:0},
  winner: null
};
const el = id => document.getElementById(id);

/* =========================
   Utilities / rendering
   ========================= */
function clamp(n){ return Math.max(0, Math.floor(n)); }

function render(){
  el('p1-authority').textContent = Math.max(0, state.p1.authority);
  el('p2-authority').textContent = Math.max(0, state.p2.authority);
  el('p1-combat').textContent = clamp(state.p1.combat);
  el('p1-trade').textContent = clamp(state.p1.trade);
  el('p1-discards').textContent = clamp(state.p1.discards);
  el('p2-combat').textContent = clamp(state.p2.combat);
  el('p2-trade').textContent = clamp(state.p2.trade);
  el('p2-discards').textContent = clamp(state.p2.discards);

  // active half glow
  document.querySelectorAll('.half').forEach(h => h.classList.remove('active'));
  el(state.current).classList.add('active');

  // end buttons text and style when combat > 0
  ['p1','p2'].forEach(p=>{
    const btn = el(p+'-end');
    const combat = state[p].combat;
    if (combat > 0) {
      btn.textContent = 'ATTACK & END TURN';
      btn.classList.add('attack');
    } else {
      btn.textContent = 'END TURN';
      btn.classList.remove('attack');
    }
  });
}

/* =========================
   Hold-to-change logic (fixed)
   ========================= */
let repeatTimeout = null;
let repeatInterval = null;
let activeButton = null;

function clearRepeat() {
  if (repeatTimeout) { clearTimeout(repeatTimeout); repeatTimeout = null; }
  if (repeatInterval) { clearInterval(repeatInterval); repeatInterval = null; }
  if (activeButton && activeButton.releasePointerCapture) {
    try { activeButton.releasePointerCapture(activePointerId); } catch(e) {}
  }
  activeButton = null;
  activePointerId = null;
}

// pointer id used with setPointerCapture (optional)
let activePointerId = null;

function applyDelta(player, type, delta){
  if (!['combat','trade','discards'].includes(type)) return;
  state[player][type] = clamp(state[player][type] + delta);
  render();
}

// single document-level pointerdown to handle all .btn presses
document.addEventListener('pointerdown', (e) => {
  const b = e.target.closest('.btn');
  if (!b) return;
  // identify parameters
  const player = b.getAttribute('data-player');
  const type = b.getAttribute('data-type');
  const delta = parseInt(b.getAttribute('data-delta')||0, 10);

  // prevent default so long press doesn't trigger text selection/other behavior
  e.preventDefault();

  // immediate apply
  applyDelta(player, type, delta);

  // store active button and pointerId
  activeButton = b;
  activePointerId = e.pointerId;

  // attempt pointer capture so we receive pointerup even if finger moves away
  if (b.setPointerCapture) {
    try { b.setPointerCapture(e.pointerId); } catch (err) {}
  }

  // after a short delay, begin repeating at medium pace
  clearRepeat();
  repeatTimeout = setTimeout(() => {
    repeatInterval = setInterval(() => applyDelta(player, type, delta), 160);
  }, 300);
});

// clear repeat on pointerup/pointercancel/visibility change/blur
document.addEventListener('pointerup', clearRepeat);
document.addEventListener('pointercancel', clearRepeat);
document.addEventListener('pointerleave', clearRepeat);
window.addEventListener('blur', clearRepeat);
document.addEventListener('visibilitychange', () => { if (document.hidden) clearRepeat(); });

/* =========================
   End Turn / Attack logic
   ========================= */
function endTurn(player){
  // only allow active player to end
  if (state.current !== player) {
    return;
  }
  const opponent = player === 'p1' ? 'p2' : 'p1';
  const combat = clamp(state[player].combat);

  if (combat > 0) {
    // apply combat to opponent authority
    state[opponent].authority = clamp(state[opponent].authority - combat);
  }
  // reset current player's per-turn counters
  state[player].combat = 0;
  state[player].trade = 0;
  state[player].discards = 0;

  // check for win AFTER applying combat
  if (state[opponent].authority <= 0) {
    state.winner = player;
    showWinner(player);
  } else {
    // switch turn
    state.current = opponent;
  }
  render();
}

/* wire end turn buttons */
el('p1-end').addEventListener('click', ()=> endTurn('p1'));
el('p2-end').addEventListener('click', ()=> endTurn('p2'));

/* =========================
   Winner overlay + fireworks
   ========================= */
const overlay = el('overlay');
const overlayText = el('overlay-text');
el('new-game').addEventListener('click', ()=>{
  // reset
  state.current = 'p1';
  state.p1 = {authority:50, combat:0, trade:0, discards:0};
  state.p2 = {authority:50, combat:0, trade:0, discards:0};
  state.winner = null;
  overlay.style.display = 'none';
  stopFireworks();
  render();
});

function showWinner(attacker){
  overlayText.textContent = attacker === 'p1' ? 'PLAYER 1 WINS!' : 'PLAYER 2 WINS!';
  overlay.style.display = 'flex';
  startFireworks();
}

/* =========================
   Fullscreen
   ========================= */
const fsBtn = el('fsBtn');
fsBtn.addEventListener('click', ()=>{
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(()=>{});
  } else {
    document.exitFullscreen().catch(()=>{});
  }
});

/* =========================
   Starfield (slow drifting)
   ========================= */
const starCanvas = el('starfield');
const sctx = starCanvas.getContext('2d');
let stars = [];
function resizeStar(){
  starCanvas.width = innerWidth;
  starCanvas.height = innerHeight;
  const area = starCanvas.width * starCanvas.height;
  const count = Math.max(100, Math.min(450, Math.floor(area / 6000)));
  stars = Array.from({length:count}, ()=>({
    x: Math.random()*starCanvas.width,
    y: Math.random()*starCanvas.height,
    r: Math.random()*1.6 + 0.2,
    a: Math.random()*0.6 + 0.12,
    dx: (Math.random()-0.5) * 0.18,
    dy: (Math.random()-0.5) * 0.18,
    tw: Math.random()*Math.PI*2
  }));
}
window.addEventListener('resize', resizeStar); resizeStar();

function drawStars(){
  sctx.clearRect(0,0,starCanvas.width, starCanvas.height);
  for (const s of stars){
    s.x += s.dx; s.y += s.dy; s.tw += 0.01;
    if (s.x < 0) s.x = starCanvas.width;
    if (s.x > starCanvas.width) s.x = 0;
    if (s.y < 0) s.y = starCanvas.height;
    if (s.y > starCanvas.height) s.y = 0;
    const alpha = Math.max(0.05, Math.min(1, s.a + Math.sin(s.tw) * 0.12));
    sctx.fillStyle = `rgba(255,255,255,${alpha})`;
    sctx.beginPath(); sctx.arc(s.x, s.y, s.r, 0, Math.PI*2); sctx.fill();
  }
  requestAnimationFrame(drawStars);
}
drawStars();

/* =========================
   Fireworks (front layer)
   ========================= */
const fwCanvas = el('fireworks');
const fctx = fwCanvas.getContext('2d');
let fwParticles = [], fwTimer = null, fwRunning = false;

function resizeFW(){ fwCanvas.width = innerWidth; fwCanvas.height = innerHeight; }
window.addEventListener('resize', resizeFW); resizeFW();

function spawnFirework(){
  const x = Math.random() * fwCanvas.width * 0.86 + fwCanvas.width*0.07;
  const y = Math.random() * fwCanvas.height * 0.5 + fwCanvas.height*0.08;
  const hue = Math.floor(Math.random() * 360);
  const count = 70 + Math.floor(Math.random()*40);
  for (let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = 1.3 + Math.random()*4;
    fwParticles.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,life:60+Math.random()*60,hue,alpha:1});
  }
}

function drawFW(){
  if(!fwRunning) return;
  fctx.clearRect(0,0,fwCanvas.width, fwCanvas.height);
  for (let i=fwParticles.length-1;i>=0;i--){
    const p = fwParticles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.03; p.vx *= 0.997;
    p.life -= 1; p.alpha = Math.max(0, p.life / 140);
    fctx.fillStyle = `hsla(${p.hue},100%,60%,${p.alpha})`;
    fctx.fillRect(p.x, p.y, 2, 2);
    if (p.life <= 0) fwParticles.splice(i,1);
  }
  requestAnimationFrame(drawFW);
}

function startFireworks(){
  if (fwRunning) return;
  fwRunning = true;
  spawnFirework();
  fwTimer = setInterval(spawnFirework, 700);
  drawFW();
}
function stopFireworks(){
  fwRunning = false;
  clearInterval(fwTimer);
  fwParticles = [];
  fctx.clearRect(0,0,fwCanvas.width, fwCanvas.height);
}

/* =========================
   Boot
   ========================= */
render();
</script>
</body>
</html>
